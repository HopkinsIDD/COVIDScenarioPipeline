<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1">


<meta name="date" content="2019-12-08" />

<title>Secondary indices and auto indexing</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />




</head>

<body>




<h1 class="title toc-ignore">Secondary indices and auto indexing</h1>
<h4 class="date">2019-12-08</h4>



<p>This vignette assumes that the reader is familiar with data.table’s <code>[i, j, by]</code> syntax, and how to perform fast key based subsets. If you’re not familiar with these concepts, please read the <em>“Introduction to data.table”</em>, <em>“Reference semantics”</em> and <em>“Keys and fast binary search based subset”</em> vignettes first.</p>
<hr />
<div id="data" class="section level2">
<h2>Data</h2>
<p>We will use the same <code>flights</code> data as in the <em>“Introduction to data.table”</em> vignette.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">flights &lt;-<span class="st"> </span><span class="kw">fread</span>(<span class="st">&quot;flights14.csv&quot;</span>)
<span class="kw">head</span>(flights)
<span class="co">#    year month day dep_delay arr_delay carrier origin dest air_time distance hour</span>
<span class="co"># 1: 2014     1   1        14        13      AA    JFK  LAX      359     2475    9</span>
<span class="co"># 2: 2014     1   1        -3        13      AA    JFK  LAX      363     2475   11</span>
<span class="co"># 3: 2014     1   1         2         9      AA    JFK  LAX      351     2475   19</span>
<span class="co"># 4: 2014     1   1        -8       -26      AA    LGA  PBI      157     1035    7</span>
<span class="co"># 5: 2014     1   1         2         1      AA    JFK  LAX      350     2475   13</span>
<span class="co"># 6: 2014     1   1         4         0      AA    EWR  LAX      339     2454   18</span>
<span class="kw">dim</span>(flights)
<span class="co"># [1] 253316     11</span></code></pre></div>
</div>
<div id="introduction" class="section level2">
<h2>Introduction</h2>
<p>In this vignette, we will</p>
<ul>
<li><p>discuss <em>secondary indices</em> and provide rationale as to why we need them by citing cases where setting keys is not necessarily ideal,</p></li>
<li><p>perform fast subsetting, once again, but using the new <code>on</code> argument, which computes secondary indices internally for the task (temporarily), and reuses if one already exists,</p></li>
<li><p>and finally look at <em>auto indexing</em> which goes a step further and creates secondary indices automatically, but does so on native R syntax for subsetting.</p></li>
</ul>
</div>
<div id="secondary-indices" class="section level2">
<h2>1. Secondary indices</h2>
<div id="a-what-are-secondary-indices" class="section level3">
<h3>a) What are secondary indices?</h3>
<p>Secondary indices are similar to <code>keys</code> in <em>data.table</em>, except for two major differences:</p>
<ul>
<li><p>It <em>doesn’t</em> physically reorder the entire data.table in RAM. Instead, it only computes the order for the set of columns provided and stores that <em>order vector</em> in an additional attribute called <code>index</code>.</p></li>
<li><p>There can be more than one secondary index for a data.table (as we will see below).</p></li>
</ul>
</div>
<div id="b-set-and-get-secondary-indices" class="section level3">
<h3>b) Set and get secondary indices</h3>
<div id="how-can-we-set-the-column-origin-as-a-secondary-index-in-the-data.table-flights" class="section level4">
<h4>– How can we set the column <code>origin</code> as a secondary index in the <em>data.table</em> <code>flights</code>?</h4>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">setindex</span>(flights, origin)
<span class="kw">head</span>(flights)
<span class="co">#    year month day dep_delay arr_delay carrier origin dest air_time distance hour</span>
<span class="co"># 1: 2014     1   1        14        13      AA    JFK  LAX      359     2475    9</span>
<span class="co"># 2: 2014     1   1        -3        13      AA    JFK  LAX      363     2475   11</span>
<span class="co"># 3: 2014     1   1         2         9      AA    JFK  LAX      351     2475   19</span>
<span class="co"># 4: 2014     1   1        -8       -26      AA    LGA  PBI      157     1035    7</span>
<span class="co"># 5: 2014     1   1         2         1      AA    JFK  LAX      350     2475   13</span>
<span class="co"># 6: 2014     1   1         4         0      AA    EWR  LAX      339     2454   18</span>

## alternatively we can provide character vectors to the function 'setindexv()'
<span class="co"># setindexv(flights, &quot;origin&quot;) # useful to program with</span>

<span class="co"># 'index' attribute added</span>
<span class="kw">names</span>(<span class="kw">attributes</span>(flights))
<span class="co"># [1] &quot;names&quot;             &quot;row.names&quot;         &quot;class&quot;             &quot;.internal.selfref&quot;</span>
<span class="co"># [5] &quot;index&quot;</span></code></pre></div>
<ul>
<li><code>setindex</code> and <code>setindexv()</code> allows adding a secondary index to the data.table.</li>
<li>Originally it was <code>set2key</code> until data.table 1.9.6, then <a href="https://github.com/Rdatatable/data.table/issues/1442">changed to current names</a>.</li>
<li><p>Note that <code>flights</code> is <strong>not</strong> physically reordered in increasing order of <code>origin</code>, as would have been the case with <code>setkey()</code>.</p></li>
<li><p>Also note that the attribute <code>index</code> has been added to <code>flights</code>.</p></li>
<li><p><code>setindex(flights, NULL)</code> would remove all secondary indices.</p></li>
</ul>
</div>
<div id="how-can-we-get-all-the-secondary-indices-set-so-far-in-flights" class="section level4">
<h4>– How can we get all the secondary indices set so far in <code>flights</code>?</h4>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">indices</span>(flights)
<span class="co"># [1] &quot;origin&quot;</span>

<span class="kw">setindex</span>(flights, origin, dest)
<span class="kw">indices</span>(flights)
<span class="co"># [1] &quot;origin&quot;       &quot;origin__dest&quot;</span></code></pre></div>
<ul>
<li><p>The function <code>indices()</code> returns all current secondary indices in the data.table. If none exists, <code>NULL</code> is returned.</p></li>
<li><p>Note that by creating another index on the columns <code>origin, dest</code>, we do not lose the first index created on the column <code>origin</code>, i.e., we can have multiple secondary indices.</p></li>
</ul>
</div>
</div>
<div id="c-why-do-we-need-secondary-indices" class="section level3">
<h3>c) Why do we need secondary indices?</h3>
<div id="reordering-a-data.table-can-be-expensive-and-not-always-ideal" class="section level4">
<h4>– Reordering a data.table can be expensive and not always ideal</h4>
<p>Consider the case where you would like to perform a fast key based subset on <code>origin</code> column for the value “JFK”. We’d do this as:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## not run
<span class="kw">setkey</span>(flights, origin)
flights[<span class="st">&quot;JFK&quot;</span>] <span class="co"># or flights[.(&quot;JFK&quot;)]</span></code></pre></div>
</div>
<div id="setkey-requires" class="section level4 bs-callout bs-callout-info">
<h4><code>setkey()</code> requires:</h4>
<ol style="list-style-type: lower-alpha">
<li><p>computing the order vector for the column(s) provided, here, <code>origin</code>, and</p></li>
<li><p>reordering the entire data.table, by reference, based on the order vector computed.</p></li>
</ol>
</div>
</div>
</div>
<div id="section" class="section level1">
<h1></h1>
<p>Computing the order isn’t the time consuming part, since data.table uses true radix sorting on integer, character and numeric vectors. However reordering the data.table could be time consuming (depending on the number of rows and columns).</p>
<p>Unless our task involves repeated subsetting on the same column, fast key based subsetting could effectively be nullified by the time to reorder, depending on our data.table dimensions.</p>
<div id="there-can-be-only-one-key-at-the-most" class="section level4">
<h4>– There can be only one <code>key</code> at the most</h4>
<p>Now if we would like to repeat the same operation but on <code>dest</code> column instead, for the value “LAX”, then we have to <code>setkey()</code>, <em>again</em>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## not run
<span class="kw">setkey</span>(flights, dest)
flights[<span class="st">&quot;LAX&quot;</span>]</code></pre></div>
<p>And this reorders <code>flights</code> by <code>dest</code>, <em>again</em>. What we would really like is to be able to perform the fast subsetting by eliminating the reordering step.</p>
<p>And this is precisely what <em>secondary indices</em> allow for!</p>
</div>
<div id="secondary-indices-can-be-reused" class="section level4">
<h4>– Secondary indices can be reused</h4>
<p>Since there can be multiple secondary indices, and creating an index is as simple as storing the order vector as an attribute, this allows us to even eliminate the time to recompute the order vector if an index already exists.</p>
</div>
<div id="the-new-on-argument-allows-for-cleaner-syntax-and-automatic-creation-and-reuse-of-secondary-indices" class="section level4">
<h4>– The new <code>on</code> argument allows for cleaner syntax and automatic creation and reuse of secondary indices</h4>
<p>As we will see in the next section, the <code>on</code> argument provides several advantages:</p>
</div>
<div id="on-argument" class="section level4 bs-callout bs-callout-info">
<h4><code>on</code> argument</h4>
<ul>
<li><p>enables subsetting by computing secondary indices on the fly. This eliminates having to do <code>setindex()</code> every time.</p></li>
<li><p>allows easy reuse of existing indices by just checking the attributes.</p></li>
<li><p>allows for a cleaner syntax by having the columns on which the subset is performed as part of the syntax. This makes the code easier to follow when looking at it at a later point.</p>
<p>Note that <code>on</code> argument can also be used on keyed subsets as well. In fact, we encourage to provide the <code>on</code> argument even when subsetting using keys for better readability.</p></li>
</ul>
</div>
</div>
<div id="section-1" class="section level1">
<h1></h1>
<div id="fast-subsetting-using-on-argument-and-secondary-indices" class="section level2">
<h2>2. Fast subsetting using <code>on</code> argument and secondary indices</h2>
<div id="a-fast-subsets-in-i" class="section level3">
<h3>a) Fast subsets in <code>i</code></h3>
<div id="subset-all-rows-where-the-origin-airport-matches-jfk-using-on" class="section level4">
<h4>– Subset all rows where the origin airport matches <em>“JFK”</em> using <code>on</code></h4>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">flights[<span class="st">&quot;JFK&quot;</span>, on =<span class="st"> &quot;origin&quot;</span>]
<span class="co">#        year month day dep_delay arr_delay carrier origin dest air_time distance hour</span>
<span class="co">#     1: 2014     1   1        14        13      AA    JFK  LAX      359     2475    9</span>
<span class="co">#     2: 2014     1   1        -3        13      AA    JFK  LAX      363     2475   11</span>
<span class="co">#     3: 2014     1   1         2         9      AA    JFK  LAX      351     2475   19</span>
<span class="co">#     4: 2014     1   1         2         1      AA    JFK  LAX      350     2475   13</span>
<span class="co">#     5: 2014     1   1        -2       -18      AA    JFK  LAX      338     2475   21</span>
<span class="co">#    ---                                                                              </span>
<span class="co"># 81479: 2014    10  31        -4       -21      UA    JFK  SFO      337     2586   17</span>
<span class="co"># 81480: 2014    10  31        -2       -37      UA    JFK  SFO      344     2586   18</span>
<span class="co"># 81481: 2014    10  31         0       -33      UA    JFK  LAX      320     2475   17</span>
<span class="co"># 81482: 2014    10  31        -6       -38      UA    JFK  SFO      343     2586    9</span>
<span class="co"># 81483: 2014    10  31        -6       -38      UA    JFK  LAX      323     2475   11</span>

## alternatively
<span class="co"># flights[.(&quot;JFK&quot;), on = &quot;origin&quot;] (or) </span>
<span class="co"># flights[list(&quot;JFK&quot;), on = &quot;origin&quot;]</span></code></pre></div>
<ul>
<li><p>This statement performs a fast binary search based subset as well, by computing the index on the fly. However, note that it doesn’t save the index as an attribute automatically. This may change in the future.</p></li>
<li><p>If we had already created a secondary index, using <code>setindex()</code>, then <code>on</code> would reuse it instead of (re)computing it. We can see that by using <code>verbose = TRUE</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">setindex</span>(flights, origin)
flights[<span class="st">&quot;JFK&quot;</span>, on =<span class="st"> &quot;origin&quot;</span>, verbose =<span class="st"> </span><span class="ot">TRUE</span>][<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>]
<span class="co"># i.V1 has same type (character) as x.origin. No coercion needed.</span>
<span class="co"># on= matches existing index, using index</span>
<span class="co"># Starting bmerge ...</span>
<span class="co"># forder.c received 1 rows and 1 columns</span>
<span class="co"># bmerge done in 0.000s elapsed (0.000s cpu) </span>
<span class="co"># Constructing irows for '!byjoin || nqbyjoin' ... 0.000s elapsed (0.001s cpu) </span>
<span class="co"># Reorder irows for 'mult==&quot;all&quot; &amp;&amp; !allGrp1' ... forder.c received 81483 rows and 2 columns</span>
<span class="co"># 0.001s elapsed (0.001s cpu)</span>
<span class="co">#    year month day dep_delay arr_delay carrier origin dest air_time distance hour</span>
<span class="co"># 1: 2014     1   1        14        13      AA    JFK  LAX      359     2475    9</span>
<span class="co"># 2: 2014     1   1        -3        13      AA    JFK  LAX      363     2475   11</span>
<span class="co"># 3: 2014     1   1         2         9      AA    JFK  LAX      351     2475   19</span>
<span class="co"># 4: 2014     1   1         2         1      AA    JFK  LAX      350     2475   13</span>
<span class="co"># 5: 2014     1   1        -2       -18      AA    JFK  LAX      338     2475   21</span></code></pre></div></li>
</ul>
</div>
<div id="how-can-i-subset-based-on-origin-and-dest-columns" class="section level4">
<h4>– How can I subset based on <code>origin</code> <em>and</em> <code>dest</code> columns?</h4>
<p>For example, if we want to subset <code>&quot;JFK&quot;, &quot;LAX&quot;</code> combination, then:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">flights[.(<span class="st">&quot;JFK&quot;</span>, <span class="st">&quot;LAX&quot;</span>), on =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;origin&quot;</span>, <span class="st">&quot;dest&quot;</span>)][<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>]
<span class="co">#    year month day dep_delay arr_delay carrier origin dest air_time distance hour</span>
<span class="co"># 1: 2014     1   1        14        13      AA    JFK  LAX      359     2475    9</span>
<span class="co"># 2: 2014     1   1        -3        13      AA    JFK  LAX      363     2475   11</span>
<span class="co"># 3: 2014     1   1         2         9      AA    JFK  LAX      351     2475   19</span>
<span class="co"># 4: 2014     1   1         2         1      AA    JFK  LAX      350     2475   13</span>
<span class="co"># 5: 2014     1   1        -2       -18      AA    JFK  LAX      338     2475   21</span></code></pre></div>
<ul>
<li><p><code>on</code> argument accepts a character vector of column names corresponding to the order provided to <code>i-argument</code>.</p></li>
<li><p>Since the time to compute the secondary index is quite small, we don’t have to use <code>setindex()</code>, unless, once again, the task involves repeated subsetting on the same column.</p></li>
</ul>
</div>
</div>
<div id="b-select-in-j" class="section level3">
<h3>b) Select in <code>j</code></h3>
<p>All the operations we will discuss below are no different to the ones we already saw in the <em>Keys and fast binary search based subset</em> vignette. Except we’ll be using the <code>on</code> argument instead of setting keys.</p>
<div id="return-arr_delay-column-alone-as-a-data.table-corresponding-to-origin-lga-and-dest-tpa" class="section level4">
<h4>– Return <code>arr_delay</code> column alone as a data.table corresponding to <code>origin = &quot;LGA&quot;</code> and <code>dest = &quot;TPA&quot;</code></h4>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">flights[.(<span class="st">&quot;LGA&quot;</span>, <span class="st">&quot;TPA&quot;</span>), .(arr_delay), on =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;origin&quot;</span>, <span class="st">&quot;dest&quot;</span>)]
<span class="co">#       arr_delay</span>
<span class="co">#    1:         1</span>
<span class="co">#    2:        14</span>
<span class="co">#    3:       -17</span>
<span class="co">#    4:        -4</span>
<span class="co">#    5:       -12</span>
<span class="co">#   ---          </span>
<span class="co"># 1848:        39</span>
<span class="co"># 1849:       -24</span>
<span class="co"># 1850:       -12</span>
<span class="co"># 1851:        21</span>
<span class="co"># 1852:       -11</span></code></pre></div>
</div>
</div>
<div id="c-chaining" class="section level3">
<h3>c) Chaining</h3>
<div id="on-the-result-obtained-above-use-chaining-to-order-the-column-in-decreasing-order." class="section level4">
<h4>– On the result obtained above, use chaining to order the column in decreasing order.</h4>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">flights[.(<span class="st">&quot;LGA&quot;</span>, <span class="st">&quot;TPA&quot;</span>), .(arr_delay), on =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;origin&quot;</span>, <span class="st">&quot;dest&quot;</span>)][<span class="kw">order</span>(<span class="op">-</span>arr_delay)]
<span class="co">#       arr_delay</span>
<span class="co">#    1:       486</span>
<span class="co">#    2:       380</span>
<span class="co">#    3:       351</span>
<span class="co">#    4:       318</span>
<span class="co">#    5:       300</span>
<span class="co">#   ---          </span>
<span class="co"># 1848:       -40</span>
<span class="co"># 1849:       -43</span>
<span class="co"># 1850:       -46</span>
<span class="co"># 1851:       -48</span>
<span class="co"># 1852:       -49</span></code></pre></div>
</div>
</div>
<div id="d-compute-or-do-in-j" class="section level3">
<h3>d) Compute or <em>do</em> in <code>j</code></h3>
<div id="find-the-maximum-arrival-delay-corresponding-to-origin-lga-and-dest-tpa." class="section level4">
<h4>– Find the maximum arrival delay corresponding to <code>origin = &quot;LGA&quot;</code> and <code>dest = &quot;TPA&quot;</code>.</h4>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">flights[.(<span class="st">&quot;LGA&quot;</span>, <span class="st">&quot;TPA&quot;</span>), <span class="kw">max</span>(arr_delay), on =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;origin&quot;</span>, <span class="st">&quot;dest&quot;</span>)]
<span class="co"># [1] 486</span></code></pre></div>
</div>
</div>
<div id="e-sub-assign-by-reference-using-in-j" class="section level3">
<h3>e) <em>sub-assign</em> by reference using <code>:=</code> in <code>j</code></h3>
<p>We have seen this example already in the <em>Reference semantics</em> and <em>Keys and fast binary search based subset</em> vignette. Let’s take a look at all the <code>hours</code> available in the <code>flights</code> <em>data.table</em>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># get all 'hours' in flights</span>
flights[, <span class="kw">sort</span>(<span class="kw">unique</span>(hour))]
<span class="co">#  [1]  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24</span></code></pre></div>
<p>We see that there are totally <code>25</code> unique values in the data. Both <em>0</em> and <em>24</em> hours seem to be present. Let’s go ahead and replace <em>24</em> with <em>0</em>, but this time using <code>on</code> instead of setting keys.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">flights[.(24L), hour <span class="op">:</span><span class="er">=</span><span class="st"> </span>0L, on =<span class="st"> &quot;hour&quot;</span>]</code></pre></div>
<p>Now, let’s check if <code>24</code> is replaced with <code>0</code> in the <code>hour</code> column.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">flights[, <span class="kw">sort</span>(<span class="kw">unique</span>(hour))]
<span class="co">#  [1]  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23</span></code></pre></div>
<ul>
<li>This is particularly a huge advantage of secondary indices. Previously, just to update a few rows of <code>hour</code>, we had to <code>setkey()</code> on it, which inevitably reorders the entire data.table. With <code>on</code>, the order is preserved, and the operation is much faster! Looking at the code, the task we wanted to perform is also quite clear.</li>
</ul>
</div>
<div id="f-aggregation-using-by" class="section level3">
<h3>f) Aggregation using <code>by</code></h3>
<div id="get-the-maximum-departure-delay-for-each-month-corresponding-to-origin-jfk.-order-the-result-by-month" class="section level4">
<h4>– Get the maximum departure delay for each <code>month</code> corresponding to <code>origin = &quot;JFK&quot;</code>. Order the result by <code>month</code></h4>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ans &lt;-<span class="st"> </span>flights[<span class="st">&quot;JFK&quot;</span>, <span class="kw">max</span>(dep_delay), keyby =<span class="st"> </span>month, on =<span class="st"> &quot;origin&quot;</span>]
<span class="kw">head</span>(ans)
<span class="co">#    month   V1</span>
<span class="co"># 1:     1  881</span>
<span class="co"># 2:     2 1014</span>
<span class="co"># 3:     3  920</span>
<span class="co"># 4:     4 1241</span>
<span class="co"># 5:     5  853</span>
<span class="co"># 6:     6  798</span></code></pre></div>
<ul>
<li>We would have had to set the <code>key</code> back to <code>origin, dest</code> again, if we did not use <code>on</code> which internally builds secondary indices on the fly.</li>
</ul>
</div>
</div>
<div id="g-the-mult-argument" class="section level3">
<h3>g) The <em>mult</em> argument</h3>
<p>The other arguments including <code>mult</code> work exactly the same way as we saw in the <em>Keys and fast binary search based subset</em> vignette. The default value for <code>mult</code> is “all”. We can choose, instead only the “first” or “last” matching rows should be returned.</p>
<div id="subset-only-the-first-matching-row-where-dest-matches-bos-and-day" class="section level4">
<h4>– Subset only the first matching row where <code>dest</code> matches <em>“BOS”</em> and <em>“DAY”</em></h4>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">flights[<span class="kw">c</span>(<span class="st">&quot;BOS&quot;</span>, <span class="st">&quot;DAY&quot;</span>), on =<span class="st"> &quot;dest&quot;</span>, mult =<span class="st"> &quot;first&quot;</span>]
<span class="co">#    year month day dep_delay arr_delay carrier origin dest air_time distance hour</span>
<span class="co"># 1: 2014     1   1         3         1      AA    JFK  BOS       39      187   12</span>
<span class="co"># 2: 2014     1   1        25        35      EV    EWR  DAY      102      533   17</span></code></pre></div>
</div>
<div id="subset-only-the-last-matching-row-where-origin-matches-lga-jfk-ewr-and-dest-matches-xna" class="section level4">
<h4>– Subset only the last matching row where <code>origin</code> matches <em>“LGA”, “JFK”, “EWR”</em> and <code>dest</code> matches <em>“XNA”</em></h4>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">flights[.(<span class="kw">c</span>(<span class="st">&quot;LGA&quot;</span>, <span class="st">&quot;JFK&quot;</span>, <span class="st">&quot;EWR&quot;</span>), <span class="st">&quot;XNA&quot;</span>), on =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;origin&quot;</span>, <span class="st">&quot;dest&quot;</span>), mult =<span class="st"> &quot;last&quot;</span>]
<span class="co">#    year month day dep_delay arr_delay carrier origin dest air_time distance hour</span>
<span class="co"># 1: 2014    10  31        -5       -11      MQ    LGA  XNA      165     1147    6</span>
<span class="co"># 2:   NA    NA  NA        NA        NA    &lt;NA&gt;    JFK  XNA       NA       NA   NA</span>
<span class="co"># 3: 2014    10  31        -2       -25      EV    EWR  XNA      160     1131    6</span></code></pre></div>
</div>
</div>
<div id="h-the-nomatch-argument" class="section level3">
<h3>h) The <em>nomatch</em> argument</h3>
<p>We can choose if queries that do not match should return <code>NA</code> or be skipped altogether using the <code>nomatch</code> argument.</p>
<div id="from-the-previous-example-subset-all-rows-only-if-theres-a-match" class="section level4">
<h4>– From the previous example, subset all rows only if there’s a match</h4>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">flights[.(<span class="kw">c</span>(<span class="st">&quot;LGA&quot;</span>, <span class="st">&quot;JFK&quot;</span>, <span class="st">&quot;EWR&quot;</span>), <span class="st">&quot;XNA&quot;</span>), mult =<span class="st"> &quot;last&quot;</span>, on =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;origin&quot;</span>, <span class="st">&quot;dest&quot;</span>), nomatch =<span class="st"> </span><span class="ot">NULL</span>]
<span class="co">#    year month day dep_delay arr_delay carrier origin dest air_time distance hour</span>
<span class="co"># 1: 2014    10  31        -5       -11      MQ    LGA  XNA      165     1147    6</span>
<span class="co"># 2: 2014    10  31        -2       -25      EV    EWR  XNA      160     1131    6</span></code></pre></div>
<ul>
<li>There are no flights connecting “JFK” and “XNA”. Therefore, that row is skipped in the result.</li>
</ul>
</div>
</div>
</div>
<div id="auto-indexing" class="section level2">
<h2>3. Auto indexing</h2>
<p>First we looked at how to fast subset using binary search using <em>keys</em>. Then we figured out that we could improve performance even further and have more cleaner syntax by using secondary indices.</p>
<p>That is what <em>auto indexing</em> does. At the moment, it is only implemented for binary operators <code>==</code> and <code>%in%</code>. An index is automatically created <em>and</em> saved as an attribute. That is, unlike the <code>on</code> argument which computes the index on the fly each time (unless one already exists), a secondary index is created here.</p>
<p>Let’s start by creating a data.table big enough to highlight the advantage.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(1L)
dt =<span class="st"> </span><span class="kw">data.table</span>(<span class="dt">x =</span> <span class="kw">sample</span>(<span class="fl">1e5</span>L, <span class="fl">1e7</span>L, <span class="ot">TRUE</span>), <span class="dt">y =</span> <span class="kw">runif</span>(100L))
<span class="kw">print</span>(<span class="kw">object.size</span>(dt), <span class="dt">units =</span> <span class="st">&quot;Mb&quot;</span>)
<span class="co"># 114.4 Mb</span></code></pre></div>
<p>When we use <code>==</code> or <code>%in%</code> on a single column for the first time, a secondary index is created automatically, and it is used to perform the subset.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## have a look at all the attribute names
<span class="kw">names</span>(<span class="kw">attributes</span>(dt))
<span class="co"># [1] &quot;names&quot;             &quot;row.names&quot;         &quot;class&quot;             &quot;.internal.selfref&quot;</span>

## run thefirst time
(t1 &lt;-<span class="st"> </span><span class="kw">system.time</span>(ans &lt;-<span class="st"> </span>dt[x <span class="op">==</span><span class="st"> </span>989L]))
<span class="co">#    user  system elapsed </span>
<span class="co">#   0.548   0.043   0.190</span>
<span class="kw">head</span>(ans)
<span class="co">#      x         y</span>
<span class="co"># 1: 989 0.7757157</span>
<span class="co"># 2: 989 0.6813302</span>
<span class="co"># 3: 989 0.2815894</span>
<span class="co"># 4: 989 0.4954259</span>
<span class="co"># 5: 989 0.7885886</span>
<span class="co"># 6: 989 0.5547504</span>

## secondary index is created
<span class="kw">names</span>(<span class="kw">attributes</span>(dt))
<span class="co"># [1] &quot;names&quot;             &quot;row.names&quot;         &quot;class&quot;             &quot;.internal.selfref&quot;</span>
<span class="co"># [5] &quot;index&quot;</span>

<span class="kw">indices</span>(dt)
<span class="co"># [1] &quot;x&quot;</span></code></pre></div>
<p>The time to subset the first time is the time to create the index + the time to subset. Since creating a secondary index involves only creating the order vector, this combined operation is faster than vector scans in many cases. But the real advantage comes in successive subsets. They are extremely fast.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## successive subsets
(t2 &lt;-<span class="st"> </span><span class="kw">system.time</span>(dt[x <span class="op">==</span><span class="st"> </span>989L]))
<span class="co">#    user  system elapsed </span>
<span class="co">#   0.008   0.002   0.007</span>
<span class="kw">system.time</span>(dt[x <span class="op">%in%</span><span class="st"> </span><span class="dv">1989</span><span class="op">:</span><span class="dv">2012</span>])
<span class="co">#    user  system elapsed </span>
<span class="co">#   0.012   0.000   0.007</span></code></pre></div>
<ul>
<li><p>Running the first time took 0.190 seconds where as the second time took 0.007 seconds.</p></li>
<li><p>Auto indexing can be disabled by setting the global argument <code>options(datatable.auto.index = FALSE)</code>.</p></li>
<li><p>Disabling auto indexing still allows to use indices created explicitly with <code>setindex</code> or <code>setindexv</code>. You can disable indices fully by setting global argument <code>options(datatable.use.index = FALSE)</code>.</p></li>
</ul>
</div>
</div>
<div id="section-2" class="section level1">
<h1></h1>
<p>In recent version we extended auto indexing to expressions involving more than one column (combined with <code>&amp;</code> operator). In the future, we plan to extend binary search to work with more binary operators like <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code> and <code>&gt;=</code>.</p>
<p>We will discuss fast <em>subsets</em> using keys and secondary indices to <em>joins</em> in the next vignette, <em>“Joins and rolling joins”</em>.</p>
<hr />
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>

---
title: "R Notebook"
params:
  config_file: config_statelevel_2020_incidCchange.yml
  continue_on_error: yes
  hosp_eval: no
  pi_hi: 0.95
  pi_lo: 0.05
  runs_folder: model_output_2020_incidCchange # directory with model output (i.e. with subdirs: hosp, snpi, spar)
  pdeath_default: "med"
  states: ["AZ","CA","DC", "IL","MA","MI","NY","WA"]
output:
  html_document:
    df_print: paged
    toc: true
    toc_depth: 3
editor_options:
  chunk_output_type: inline
#Note: For now it seems like this notebook must be in the main folder of COVID19_USA (although it is supposed to be able to find the correct directory)
---

```{r setup, include=F}

## Block with general knitr options, library load, etc. Nothing specific to the project.
knitr::opts_knit$set(eval.after = 'fig.cap',
                     root.dir = rprojroot::find_root(rprojroot::has_file(params$config_file))) # the root does not seem to be working and carrying thru to other chunks

knitr::opts_chunk$set(
  echo = FALSE,
  fig.align = "center",
  message = FALSE,
  warning = FALSE,
  error = params$continue_on_error,
  cache.lazy = FALSE,
  bitmapType = "cairo"
)

options(scipen=999)

#Preamble   
# Make sure to run local_install.R first
library(tidyverse)
library(covidcommon)
library(report.generation)
library(covidImportation)
library(ggtext)
library(cowplot)
library(googlesheets4)
#library(covidHubUtils)
library(gtsummary)
library(zoo)
library(corrplot)
library(reshape2)
```

```{r parameter_definitions}
# # All of this should be in notebook header but not working!
# config_file=' config_inference_scenarioproj_baseline_28jan.yml'
# continue_on_error= 'yes'
# hosp_eval= 'no'
# pi_hi= 0.95
# pi_lo= 0.05
# runs_folder= 'model_output' # directory with model output (i.e. with subdirs: hosp, snpi, spar)
# state_usps= 'CA'
# pdeath_default= "med"

config_file=params$config_file
continue_on_error= params$continue_on_error
hosp_eval=params$hosp_eval
pi_hi= params$pi_hi
pi_lo= params$pi_hi
runs_folder= params$runs_folder
states= params$states
pdeath_default= params$pdeath_default

pdeath_label= "0.5% IFR"
projection_start= Sys.Date()
```

```{r rmd_formatting}
fig_counter <- 1
tab_counter <- 1

min_date<-Sys.Date()-45
max_date<-lubridate::ceiling_date(lubridate::ymd(projection_start), "week")+7*3

min_date<-lubridate::floor_date(min_date, "month")
display_dates<-c(projection_start, max_date-7*3, max_date-7*2, max_date-7, max_date)
```


```{r load_config}
config <- covidcommon::load_config(params$config_file)
```


```{r config_vals}
simulations_per_slot <- config$simulations_per_slot
scn_labels <- "inference"
scn_levels <- "inference"
scn_colors = c("#550055")
# scn_labels <- config$report$formatting$scenario_labels
# scn_levels<-config$report$formatting$scenario_levels
sim_start_date <- config$start_date
sim_end_date <- config$end_date
```

# Generate state or county level output


```{r}

# Load in basic information on geoIDs of interest

geodata_all <- load_geodata_file(file.path(config$spatial_setup$base_path, config$spatial_setup$geodata),
                                 geoid_len=5,
                                 names=TRUE)  %>%
  mutate(name=str_to_title(name)) %>%
  rename(pop=starts_with("pop"))

included_geoids_all <- geodata_all$geoid

geodata_some <-geodata_all %>% dplyr::filter(USPS %in% states)

included_geoids_some <- geodata_some$geoid
```

```{r}
#NOTES on how to split file names for intermediate runs

# change the file name values, which are saved in sim_num, from long strings of the form job.slot.run.date to slot only
# hosp <- hosp %>%
#   mutate(sim_num=as.numeric(paste(head(str_split(sim_num,'\\.')[[1]],-7),collapse='.')),time=as.Date(time))
```

```{r load_model_timecourse_summed}  
# Gets model outcomes over time summed over all geoIDs of interest
#Only need if we did simulation on the county level and need to sum for state level
model_output_summed <-load_hosp_geocombined_totals(runs_folder,
                                                   scenario_levels = scn_levels,
                                                   scenario_labels = scn_labels,
                                                   incl_geoids = included_geoids_all,
                                                   pdeath_filter=pdeath_default)
# 
# sim_sample<-sample(unique(state_hosp_totals$sim_num), 
#                          min(nfiles2, length(unique(state_hosp_totals$sim_num))),
#                          replace=FALSE)

```



```{r load_model_timecourse} 
# Gets model outcomes over time for all geoIDs of interest individually
model_timecourse_all <- load_hosp_county(runs_folder, 
                                         scenario_levels = scn_levels,
                                         scenario_labels = scn_labels,
                                         incl_geoids=included_geoids_all,
                                         pdeath_filter = pdeath_default)  %>%
  left_join(geodata_all) %>%
  mutate(name = factor(name, levels=sort(geodata_all$name, decreasing=TRUE)))

model_timecourse_some <-model_timecourse_all %>% dplyr::filter(USPS %in% states)

```


```{r load_truth}

# Get up to date data on cases, deaths, and hospitalizations - takes a long time to run

#truth_dat <-get_groundtruth_from_source(source="csse") # for county level
truth_dat_raw <- covidcommon::get_groundtruth_from_source(source = "csse", scale = "US state")

```


```{r load_truth_all}

truth_dat_all<-truth_dat_raw%>%
  dplyr::select(Confirmed, Deaths, incidI, incidDeath, source, date=Update, geoid=FIPS) %>%
  left_join(geodata_all)

truth_dat_some <-truth_dat_all %>% dplyr::filter(USPS %in% states)

```



```{r load_hosp_data}
# State level hospitalization data
hosp_dat_all<-get_hhsCMU_incidH_st_data() %>%
  dplyr::select(date=Update, USPS=source, incidH=incidH_confirmed)%>%
  #filter(USPS==reportStateUSPS) %>% 
  drop_na() 

hosp_dat_all <- geodata_all %>%
  left_join(hosp_dat_all)

hosp_dat_some <-hosp_dat_all %>% dplyr::filter(USPS %in% states)

# This is specific to California data!
# #only works by county. only has county name, not FIPS - not sure how they treat redudant counties!
# currhosp_dat <- read.csv("https://data.ca.gov/dataset/529ac907-6ba1-4cb7-9aae-8966fc96aeef/resource/42d33765-20fd-44b8-a978-b083b7542225/download/hospitals_by_county.csv") %>%
#     dplyr::rename(name = county, 
#                   date = todays_date,
#                   currhosp=hospitalized_covid_confirmed_patients) %>%
#   tibble()

# currhosp_dat <- currhosp_dat %>%
#     left_join(geodata) %>%
#     mutate(date = lubridate::ymd(date))

# Currently hospitalized
# hosp_dat<-currhosp_dat %>%
#   group_by(date) %>%
#   summarize(currhosp=sum(currhosp))%>%
#   left_join(hosp_dat)
```


# Plot the epidemic timecourse from simulations vs data 

## Summed over all states

Using the final output from each simulation

```{r calib}

# Creates plots for state-level time course of cases + deaths (+hospitalization), model + data, for final parameter values from each slot

# combine case + death data with hospitalization data
# Right now doesn't work 
# obs_dat<-currhosp_dat%>%
#   select(geoid, date, currhosp)%>%
#   left_join(truth_dat)

obs_dat<-truth_dat_all 

calib_plts <- plot_model_vs_obs(model_output_summed,
                                jhu_obs_dat = obs_dat,
                                scenario_colors = scn_colors,
                                obs_data_col = "black",
                                ci.L = 0.025,
                                ci.U = 0.975,
                                date_breaks = "1 month",
                                sim_start_date = sim_start_date,
                                sim_end_date = max_date,
                                week = TRUE,
                                hosp=FALSE, tendency="median")

calib_legend<-get_legend(calib_plts[[1]]+theme(legend.position="bottom"))

#calib_plts[[1]]<-calib_plts[[1]]+theme(legend.position = "none")+scale_x_date(breaks="1 month", date_labels="%b %y")
#calib_plts[[2]]<-calib_plts[[2]]+theme(legend.position = "none")+scale_x_date(breaks="1 month", date_labels="%b %y")
calib_plts[[1]]<-calib_plts[[1]]+theme(legend.position = "none")
calib_plts[[2]]<-calib_plts[[2]]+theme(legend.position = "none")
```

```{r single_geoid_plot, fig.height=3, fig.width=10, fig.cap=cap}

state_fit<- plot_grid(NULL, NULL, NULL, NULL,
                      NULL, calib_plts[[1]], 
                      NULL, calib_plts[[2]], 
                      NULL, calib_legend, NULL, NULL,
                      ncol=4, nrow=3, 
                      rel_heights=c(0.05, 0.9, 0.05),
                      rel_widths = c(0.03, 0.47, 0.03, 0.47),
                      labels=c("", "Model Calibration", "", "",
                               "A", "", "B", ""))
state_fit

cap<-paste0("**Fig. ", fig_counter, " ** Model calibration to incident cases (A) and incident deaths (B) reported by JHU CSSE for each state at ", pdeath_label, " assumptions, summed over entire country. Shaded areas show 95% confidence intervals based on ",simulations_per_slot,"independent inference runs and black points/lines indicate data reported by JHU CSSE.")

fig_counter<-fig_counter+1
```

## For each state

(for subset of states only now)

```{r county_truth, include=FALSE}
#replace term "_some" in variables with "_all" to plot for all locations instead of subset

obs_dat_some<-hosp_dat_some %>%
  dplyr::select(USPS, date, incidH) %>%
  right_join(truth_dat_some)

calib<-plot_truth_by_location(truth_dat=obs_dat_some,
                              model_dat=model_timecourse_some,
                              start_date=sim_start_date,
                              end_date=max_date,
                              geodat=geodata_some,
                              filter_by="pdeath",
                              filter_val=pdeath_default,
                              hosp=TRUE)

cases<-calib[[1]]+theme(legend.position="none",
                        strip.text.y = element_blank(), 
                        strip.background.y = element_blank(),
                        axis.title.y = element_blank()) + background_grid()

cases<-ggplot_gtable(ggplot_build(cases))

deaths<-calib[[2]]+theme(legend.position="none",
                         #strip.text.y=element_blank(),
                         #strip.background.y=element_blank(),
                         axis.title.y = element_blank()) + background_grid()

deaths<-ggplot_gtable(ggplot_build(deaths))

# Comment out if set hosp=FALSE in calling the plotting function
hosps<-calib[[3]]+theme(legend.position="none",
                        axis.title.y = element_blank(),
                        strip.text = element_text(size=10, face="bold")) + background_grid()

hosps<-ggplot_gtable(ggplot_build(hosps))

cases$widths<-deaths$widths
hosps$widths<-deaths$widths

plot_calib<-gridExtra::grid.arrange(grobs = list(cases, deaths, hosps), ncol=3, nrow=1)
legend<-get_legend(calib[[1]]+theme(legend.position="bottom"))
```


```{r county_plot, fig.height=10, fig.width=10, fig.cap=cap}
cowplot::plot_grid(plot_calib, legend, nrow=2, rel_heights = c(1, 0.01))

cap<- paste0("**Fig. ", fig_counter, "** Calibration of estimated incident cases and deaths to reported data from JHU CSSE, and validation of estimates for occupied hospital beds when compared to CDPH data. Here, modeled cases are calculated as a percent of modeled infection that is fit to county data. Black points represent actual data, lines represent means and shading represents the 95% prediction interval for each scenario at ",pdeath_label," and 0.5% assumptions. Note that JHU CSSE data were reported as daily cumulative cases and deaths. In this figure, daily cumulative case counts were differenced in order to report the incident cases and deaths. **In comparing the actual and modeled data, we emphasize that limited testing and reporting delays may affect the quality of the reported case data early on in the outbreak.**")

fig_counter<-fig_counter+1

``` 


# Plot the likelihood by MCMC iteration - global, and chimeric for each state 


```{r}
llik_final <- load_llik_sims_filtered(outcome_dir=runs_folder, 
                                      pdeath_filter=pdeath_default, 
                                      incl_geoids=included_geoids_all) %>%
  dplyr::select(c(-filename,-date))
```

```{r}
llik_interm <- load_llik_sims_filtered_interm(outcome_dir=runs_folder, 
                                              pdeath_filter=pdeath_default, 
                                              incl_geoids=included_geoids_all) %>%
  dplyr::select(c(-filename,-date))

llik_interm  <- geodata_all %>%
  left_join(llik_interm)

llik_interm_some <-llik_interm %>% dplyr::filter(USPS %in% states)
```



```{r mcmc_llik_plot, include=FALSE}

llik_plot <- plot_llik_by_location(llik_interm_some,
                                   filter_by="pdeath",
                                   filter_val=pdeath_default,
                                   burn_in = 0
)

lik_type1 <-llik_plot[[1]]+theme(legend.position="none",
                                 #strip.text.y = element_blank(),
                                 #strip.background.y = element_blank(),
                                 #axis.title.y = element_blank(),
                                 strip.text = element_text(size=10, face="bold")) + background_grid()

lik_type1<-ggplot_gtable(ggplot_build(lik_type1))

# Uncomment if more than one scenario or death rate being included
# lik_type2 <-llik_plot[[2]]+theme(legend.position="none",
#                         #strip.text.y = element_blank(),
#                         #strip.background.y = element_blank(),
#                         #axis.title.y = element_blank(),
#                         strip.text = element_text(size=10, face="bold"))
# 
# lik_type2<-ggplot_gtable(ggplot_build(lik_type2))

# repeat for other entries in llik_plot if more scenarios were looked at

#plot_llik_grid <-gridExtra::grid.arrange(grobs = list(lik_type1,lik_type2), ncol=2, nrow=1)
plot_llik_grid <-gridExtra::grid.arrange(grobs = list(lik_type1), ncol=2, nrow=1)
legend<-get_legend(llik_plot[[1]]+theme(legend.position="top"))
```


```{r llik_plot, fig.height=10, fig.width=10, fig.cap=cap}
cowplot::plot_grid(plot_llik_grid, legend, nrow=2, rel_heights = c(1, 0.01))

cap<- paste0("**Fig. ", fig_counter, "** GeoID-specific log-likelihood values by MCMC step. Here 'chimeric' values are the likelihood for accepted parameters in the chimeric likelihood, and 'global' values are the likelihood values for the proposed parameters of the chimeric likelihood, which are recorded in the global likelihood files. These two likelihood values are equivalent only at steps where the chimeric likelihood was accepted for that GeoID.**")

fig_counter<-fig_counter+1

``` 


# Same but for combined national likelihood


```{r mcmc_llik_plot_total, include=FALSE}

llik_plot <- plot_llik_total(llik_interm,
                             filter_by="pdeath",
                             filter_val=pdeath_default,
                             burn_in = 0
)

```


```{r llik_plot_total, fig.height=2, fig.width=5, fig.cap=cap}
llik_plot[[1]]

cap<- paste0("**Fig. ", fig_counter, "** Total log-likelihood values by MCMC step (summed over all GeoIDs). Here 'chimeric' values are the total likelihood for accepted parameters in the chimeric likelihood, and 'global' values are the likelihood values for the proposed parameters of the chimeric likelihood, which are recorded in the global likelihood files. The chimeric (accepted) likelihood is always higher since acceptance decisions are made on a geoID-by-geoID level, and only accepted for GeoIDs where the acceptance would improve the geoID-specific likelihood. These two likelihood values would only be equivalent at steps where the chimeric likelihood was accepted for every single GeoID.**")

fig_counter<-fig_counter+1

``` 
# Look at proportion of likelihoods accepted or rejected

Plot chimeric acceptance rates for each state, rolling mean over all previous iterations (saved in chimeric intermediate likelihood files)

Plot when global acceptances occurred


```{r mcmc_accept_rate_plot, include=FALSE}

accept_plot <- plot_accept_by_location(llik_interm_some,
                                       filter_by="pdeath",
                                       filter_val=pdeath_default,
                                       burn_in = 0) 

accept_type1 <-accept_plot[[1]]+theme(legend.position="none",
                                      #strip.text.y = element_blank(), 
                                      #strip.background.y = element_blank(),
                                      #axis.title.y = element_blank(),
                                      strip.text = element_text(size=10, face="bold")) + background_grid()

accept_type1<-ggplot_gtable(ggplot_build(accept_type1))

# accept_type2 <-accept_plot[[2]]+theme(legend.position="none",
#                         #strip.text.y = element_blank(), 
#                         #strip.background.y = element_blank(),
#                         #axis.title.y = element_blank(),
#                         strip.text = element_text(size=10, face="bold"))
# 
# accept_type2<-ggplot_gtable(ggplot_build(accept_type2))

# repeat for other entries in llik_plot if more scenarios were looked at

#plot_accept_grid <-gridExtra::grid.arrange(grobs = list(accept_type1,accept_type2), ncol=2, nrow=1)
plot_accept_grid <-gridExtra::grid.arrange(grobs = list(accept_type1), ncol=2, nrow=1)
legend<-get_legend(accept_plot[[1]]+theme(legend.position="top"))
```


```{r accept_plot, fig.height=10, fig.width=10, fig.cap=cap}
cowplot::plot_grid(plot_accept_grid, legend, nrow=2, rel_heights = c(1, 0.01))

cap<- paste0("**Fig. ", fig_counter, "** Acceptance rate of proposed parameters by MCMC step for each state ('chimeric' values) along with the global acceptance rate. Acceptance rate is averaged over all previous steps. **")

fig_counter<-fig_counter+1

``` 

## Now plot average acceptance as rolling mean over an interval

```{r mcmc_accept_rate_plot_roll, include=FALSE}

this_roll_period = 25

accept_plot <- plot_accept_by_location_rolling(llik_interm_some,
                                               filter_by="pdeath",
                                               filter_val=pdeath_default,
                                               roll_period = this_roll_period,
                                               burn_in = 0)

accept_type1 <-accept_plot[[1]]+theme(legend.position="none",
                                      #strip.text.y = element_blank(), 
                                      #strip.background.y = element_blank(),
                                      #axis.title.y = element_blank(),
                                      strip.text = element_text(size=10, face="bold")) + background_grid()

accept_type1<-ggplot_gtable(ggplot_build(accept_type1))

# accept_type2 <-accept_plot[[2]]+theme(legend.position="none",
#                         #strip.text.y = element_blank(), 
#                         #strip.background.y = element_blank(),
#                         #axis.title.y = element_blank(),
#                         strip.text = element_text(size=10, face="bold"))
# 
# accept_type2<-ggplot_gtable(ggplot_build(accept_type2))

# repeat for other entries in llik_plot if more scenarios were looked at

#plot_accept_grid <-gridExtra::grid.arrange(grobs = list(accept_type1,accept_type2), ncol=2, nrow=1)
plot_accept_grid <-gridExtra::grid.arrange(grobs = list(accept_type1), ncol=2, nrow=1)
legend<-get_legend(accept_plot[[1]]+theme(legend.position="top"))
```


```{r accept_plot_roll, fig.height=10, fig.width=10, fig.cap=cap}
cowplot::plot_grid(plot_accept_grid, legend, nrow=2, rel_heights = c(1, 0.01))

cap<- paste0("**Fig. ", fig_counter, "** Acceptance rate of proposed parameters by MCMC step for each state ('chimeric' values) along with the global acceptance rate. Acceptance rate is averaged over the previous",this_roll_period,"steps**")

fig_counter<-fig_counter+1

``` 
## Plot cumulative acceptances


```{r mcmc_accept_cumul, include=FALSE}

accept_plot <- plot_accept_by_location_cumul(llik_interm_some,
                                             filter_by="pdeath",
                                             filter_val=pdeath_default,
                                             roll_period = this_roll_period,
                                             burn_in = 0)

accept_type1 <-accept_plot[[1]]+theme(legend.position="none",
                                      #strip.text.y = element_blank(), 
                                      #strip.background.y = element_blank(),
                                      #axis.title.y = element_blank(),
                                      strip.text = element_text(size=10, face="bold")) + background_grid()

accept_type1<-ggplot_gtable(ggplot_build(accept_type1))

# accept_type2 <-accept_plot[[2]]+theme(legend.position="none",
#                         #strip.text.y = element_blank(), 
#                         #strip.background.y = element_blank(),
#                         #axis.title.y = element_blank(),
#                         strip.text = element_text(size=10, face="bold"))
# 
# accept_type2<-ggplot_gtable(ggplot_build(accept_type2))

# repeat for other entries in llik_plot if more scenarios were looked at

#plot_accept_grid <-gridExtra::grid.arrange(grobs = list(accept_type1,accept_type2), ncol=2, nrow=1)
plot_accept_grid <-gridExtra::grid.arrange(grobs = list(accept_type1), ncol=2, nrow=1)
legend<-get_legend(accept_plot[[1]]+theme(legend.position="top"))
```


```{r accept_plot_cumul, fig.height=10, fig.width=10, fig.cap=cap}
cowplot::plot_grid(plot_accept_grid, legend, nrow=2, rel_heights = c(1, 0.01))

cap<- paste0("**Fig. ", fig_counter, "** Cumulative number of acceptances of proposed parameters by MCMC step for each state ('chimeric' values) along with the global acceptance rate**")

fig_counter<-fig_counter+1

``` 

# Plot all infered parameter values by MCMC iteration for a given state


## Look at basic SEIR parameter values
These are the same for all states, and are fixed, not estimated, so nothing to plot

```{r}
# Load final SEIR parameter values

spar_final <- load_spar_sims_filtered(outcome_dir=runs_folder, 
                                      pre_process=function(x){x}, # {x %>% dplyr::filter(parameter=="R0")}, 
                                      pdeath_filter=pdeath_default) #%>%
#dplyr::select(sim_num, scenario, pdeath, geoid, npi_name, start_date, end_date, reduction)
#dplyr::group_by(scenario) %>%
#dplyr::rename(r0=value) %>%
#dplyr::select(sim_num, scenario, pdeath, r0) %>%
#dplyr::ungroup()
```

```{r}

# Load final values of intervention parameters
spar_interm<- load_spar_sims_filtered_interm(outcome_dir=runs_folder, 
                                             pre_process=function(x){x}, 
                                             pdeath_filter=pdeath_default, 
                                             incl_geoids=included_geoids_all) %>%
  #dplyr::select(sim_num, scenario, pdeath, geoid, npi_name, start_date, end_date, reduction) # need to fix sim_num parsing
  dplyr::select(c(-location,-date))

```

```{r mcmc_spar_plot, include=FALSE}

#this_spar_filter <-c('local_variance','lockdown_partial',"seas_jul")
#this_fig_labs <- c("Local variance in R0","Partial Lockdown","July seasonality")

spar_plot <- plot_spars(spar_interm,
                        filter_by="pdeath",
                        filter_val=pdeath_default,
                        burn_in = 0#,
                        #spar_filter = this_snpi_filter,
                        #fig_labs=this_fig_labs
)

spar_type1 <-spar_plot[[1]]+theme(legend.position="none",
                                  #strip.text.y = element_blank(), 
                                  #strip.background.y = element_blank(),
                                  #axis.title.y = element_blank(),
                                  strip.text = element_text(size=10, face="bold")) + background_grid()

spar_type1<-ggplot_gtable(ggplot_build(spar_type1))

# accept_type2 <-accept_plot[[2]]+theme(legend.position="none",
#                         #strip.text.y = element_blank(), 
#                         #strip.background.y = element_blank(),
#                         #axis.title.y = element_blank(),
#                         strip.text = element_text(size=10, face="bold"))
# 
# accept_type2<-ggplot_gtable(ggplot_build(accept_type2))

# repeat for other entries in llik_plot if more scenarios were looked at

#plot_accept_grid <-gridExtra::grid.arrange(grobs = list(accept_type1,accept_type2), ncol=2, nrow=1)
plot_spar_grid <-gridExtra::grid.arrange(grobs = list(spar_type1), ncol=2, nrow=1)
legend<-get_legend(spar_plot[[1]]+theme(legend.position="top"))
```


```{r spars_plot, fig.height=10, fig.width=10, fig.cap=cap}
cowplot::plot_grid(plot_spar_grid, legend, nrow=2, rel_heights = c(1, 0.01))

cap<- paste0("**Fig. ", fig_counter, "** SEIR parameters by MCMC step ('chimeric' values) along with the global acceptance rate**")

fig_counter<-fig_counter+1

``` 

## Look at outcome model parameter values
These are the same for all states, and are fixed, not estimated, so nothing to plot

```{r}
# Load final SEIR parameter values

hpar_final <- load_hpar_sims_filtered(outcome_dir=runs_folder, 
                                      pre_process=function(x){x}, # {x %>% dplyr::filter(parameter=="R0")}, 
                                      pdeath_filter=pdeath_default,
                                      incl_geoids = included_geoids_all) #%>%
#dplyr::select(sim_num, scenario, pdeath, geoid, npi_name, start_date, end_date, reduction)
#dplyr::group_by(scenario) %>%
#dplyr::rename(r0=value) %>%
#dplyr::select(sim_num, scenario, pdeath, r0) %>%
#dplyr::ungroup()
```

```{r}

# Load final values of intervention parameters
hpar_interm<- load_hpar_sims_filtered_interm(outcome_dir=runs_folder, 
                                             pre_process=function(x){x}, 
                                             pdeath_filter=pdeath_default, 
                                             incl_geoids=included_geoids_all) %>%
  #dplyr::select(sim_num, scenario, pdeath, geoid, npi_name, start_date, end_date, reduction) # need to fix sim_num parsing
  dplyr::select(c(-location,-date))

hpar_interm  <- geodata_all %>%
  left_join(hpar_interm)

hpar_interm_some <- hpar_interm %>% dplyr::filter(USPS %in% states)

```

```{r mcmc_hpar_plot, include=FALSE}
this_hpar_filter <-c('incidC_probability','incidH_probability','incidD_probability')
this_fig_labs <- c("Case detection probability","Hospitalization probability","Death probability")

hpar_plot <- plot_hpar_by_location(hpar_interm_some,
                                   pdeath_filter = pdeath_default,
                                   scenario_filter = 'inference',
                                   hpar_filter = this_hpar_filter,
                                   fig_labs=this_fig_labs
)

hpar_plot_list <- list() 

# for first column of plots, keep y axis and remove strip label
hpar_plot_list[[1]] <- ggplot_gtable(ggplot_build(hpar_plot[[1]]+theme(legend.position="none",
                                                                       #strip.text.y = element_blank(),
                                                                       #strip.background.y = element_blank()
                                                                       strip.text = element_text(size=10, face="bold")
)))

# for last column of plots, remove y axis and keep strip label
hpar_plot_list[[length(this_hpar_filter)]] <- ggplot_gtable(ggplot_build(hpar_plot[[length(this_hpar_filter)]]+theme(legend.position="none",
                                                                                                                     strip.text = element_text(size=10, face="bold"),
                                                                                                                     axis.title.y = element_blank())))

# for all other column of plots, remove y axis and remove strip label

if (length(this_hpar_filter)>2){
  for (i in 2:(length(this_hpar_filter)-1)){
    print(i)
    hpar_plot_list[[i]] <- ggplot_gtable(ggplot_build(hpar_plot[[i]]+theme(legend.position="none",
                                                                           #strip.background.y = element_blank(),
                                                                           #strip.text.y = element_blank(),
                                                                           strip.text = element_text(size=10, face="bold"),
                                                                           axis.title.y = element_blank())))
  }
}


plot_hpar_grid <-gridExtra::grid.arrange(grobs = hpar_plot_list, ncol=length(this_hpar_filter), nrow=1)
legend<-get_legend(hpar_plot[[1]]+theme(legend.position="top"))
```


```{r hpar_plot, fig.height=10, fig.width=10, fig.cap=cap}
cowplot::plot_grid(plot_hpar_grid, legend, nrow=2, rel_heights = c(1, 0.01))

cap<- paste0("**Fig. ", fig_counter, "** Inferred outcome parameter values by MCMC step for each GeoID.'Global' values are the proposed parameters at each step, and 'Chimeric' values are the parameters accepted at the GeoID-level in the chimeric likelihood  **")

fig_counter<-fig_counter+1

``` 

## Look at intervention effects

### SNPI (NPIs acting on SEIR values)

Including local variance in R0

```{r}

# Load final values of intervention parameters

snpi_final<- load_snpi_sims_filtered(outcome_dir=runs_folder, 
                                     pre_process=function(x){x}, 
                                     pdeath_filter=pdeath_default, 
                                     incl_geoids=included_geoids_all) %>%
  dplyr::select(sim_num, scenario, pdeath, geoid, npi_name, start_date, end_date, reduction) # need to fix sim_num parsing
```

```{r}
# Load final values of intervention parameters
snpi_interm<- load_snpi_sims_filtered_interm(outcome_dir=runs_folder, 
                                             pre_process=function(x){x}, 
                                             pdeath_filter=pdeath_default, 
                                             incl_geoids=included_geoids_all) %>%
  #dplyr::select(sim_num, scenario, pdeath, geoid, npi_name, start_date, end_date, reduction) # need to fix sim_num parsing
  dplyr::select(c(-location,-date))

snpi_interm  <- geodata_all %>%
  left_join(snpi_interm)

snpi_interm_some <-snpi_interm %>% dplyr::filter(USPS %in% states)
```


```{r mcmc_snpi_plot, include=FALSE}
this_snpi_filter <-c('local_variance','lockdown','seas_jul')
this_fig_labs <- c("Local variance in R0","Lockdown","July seasonality")

snpi_plot <- plot_snpi_by_location(snpi_interm_some,
                                   pdeath_filter = pdeath_default,
                                   scenario_filter = 'inference',
                                   snpi_filter = this_snpi_filter,
                                   fig_labs=this_fig_labs
)

snpi_plot_list <- list() 

# for first column of plots, keep y axis and remove strip label
snpi_plot_list[[1]] <- ggplot_gtable(ggplot_build(snpi_plot[[1]]+theme(legend.position="none",
                                                                       #strip.text.y = element_blank(),
                                                                       #strip.background.y = element_blank()
                                                                       strip.text = element_text(size=10, face="bold")
)))

# for last column of plots, remove y axis and keep strip label
snpi_plot_list[[length(this_snpi_filter)]] <- ggplot_gtable(ggplot_build(snpi_plot[[length(this_snpi_filter)]]+theme(legend.position="none",
                                                                                                                     strip.text = element_text(size=10, face="bold"),
                                                                                                                     axis.title.y = element_blank())))

# for all other column of plots, remove y axis and remove strip label

if (length(this_snpi_filter)>2){
  for (i in 2:(length(this_snpi_filter)-1)){
    print(i)
    snpi_plot_list[[i]] <- ggplot_gtable(ggplot_build(snpi_plot[[i]]+theme(legend.position="none",
                                                                           #strip.background.y = element_blank(),
                                                                           #strip.text.y = element_blank(),
                                                                           strip.text = element_text(size=10, face="bold"),
                                                                           axis.title.y = element_blank())))
  }
}


plot_snpi_grid <-gridExtra::grid.arrange(grobs = snpi_plot_list, ncol=length(this_snpi_filter), nrow=1)
legend<-get_legend(snpi_plot[[1]]+theme(legend.position="top"))
```


```{r snpi_plot, fig.height=10, fig.width=10, fig.cap=cap}
cowplot::plot_grid(plot_snpi_grid, legend, nrow=2, rel_heights = c(1, 0.01))

cap<- paste0("**Fig. ", fig_counter, "** Inferred paramter values by MCMC step for each GeoID.'Global' values are the proposed parameters at each step, and 'Chimeric' values are the parameters accepted at the GeoID-level in the chimeric likelihood  **")

fig_counter<-fig_counter+1

``` 

## Should repeat this for HNPI parameter values

(no interventions on outcome parameters in these simulations, so files are empty and can't be opened with arrow)

```{r}

# Load final values of intervention parameters
# 
hnpi_final<- load_hnpi_sims_filtered(outcome_dir=runs_folder,
                                     pre_process=function(x){x},
                                     pdeath_filter=pdeath_default,
                                     incl_geoids=included_geoids_all) %>%
  dplyr::select(sim_num, scenario, pdeath, geoid, npi_name, start_date, end_date, reduction) # need to fix sim_num parsing
```


```{r}
# Load final values of intervention parameters
hnpi_interm<- load_hnpi_sims_filtered_interm(outcome_dir=runs_folder,
                                             pre_process=function(x){x},
                                             pdeath_filter=pdeath_default,
                                             incl_geoids=included_geoids_all) %>%
  #dplyr::select(sim_num, scenario, pdeath, geoid, npi_name, start_date, end_date, reduction) # need to fix sim_num parsing
  dplyr::select(c(-location,-date))

hnpi_interm  <- geodata_all %>%
  left_join(hnpi_interm)

hnpi_interm_some <-hnpi_interm %>% dplyr::filter(USPS %in% states)
```

```{r mcmc_hnpi_plot, include=FALSE}
this_hnpi_filter <-c('june_incidC_shift')
this_fig_labs <- c("Reduction in incidC during first half of 2020")

hnpi_plot <- plot_hnpi_by_location(hnpi_interm_some,
                                   pdeath_filter = pdeath_default,
                                   scenario_filter = 'inference',
                                   hnpi_filter = this_hnpi_filter,
                                   fig_labs=this_fig_labs
)

hnpi_plot_list <- list() 

# for first column of plots, keep y axis and remove strip label
hnpi_plot_list[[1]] <- ggplot_gtable(ggplot_build(hnpi_plot[[1]]+theme(legend.position="none",
                                                                       #strip.text.y = element_blank(),
                                                                       #strip.background.y = element_blank()
                                                                       strip.text = element_text(size=10, face="bold")
)))

# for last column of plots, remove y axis and keep strip label
snpi_plot_list[[length(this_hnpi_filter)]] <- ggplot_gtable(ggplot_build(hnpi_plot[[length(this_hnpi_filter)]]+theme(legend.position="none",
                                                                                                                     strip.text = element_text(size=10, face="bold"),
                                                                                                                     axis.title.y = element_blank())))

# for all other column of plots, remove y axis and remove strip label

if (length(this_hnpi_filter)>2){
  for (i in 2:(length(this_hnpi_filter)-1)){
    print(i)
    hnpi_plot_list[[i]] <- ggplot_gtable(ggplot_build(hnpi_plot[[i]]+theme(legend.position="none",
                                                                           #strip.background.y = element_blank(),
                                                                           #strip.text.y = element_blank(),
                                                                           strip.text = element_text(size=10, face="bold"),
                                                                           axis.title.y = element_blank())))
  }
}


plot_hnpi_grid <-gridExtra::grid.arrange(grobs = hnpi_plot_list, ncol=max(3,length(this_hnpi_filter)), nrow=1)
legend<-get_legend(hnpi_plot[[1]]+theme(legend.position="top"))
```


```{r hnpi_plot, fig.height=10, fig.width=10, fig.cap=cap}
cowplot::plot_grid(plot_hnpi_grid, legend, nrow=2, rel_heights = c(1, 0.01))

cap<- paste0("**Fig. ", fig_counter, "** Inferred paramter values by MCMC step for each GeoID.'Global' values are the proposed parameters at each step, and 'Chimeric' values are the parameters accepted at the GeoID-level in the chimeric likelihood  **")

fig_counter<-fig_counter+1

``` 


## Look at correlations between different fit parameter values, for each state

Update this to combine fit parameters of different types (snpi, hnpi, spar, hpar, etc)

```{r}

# fix this to use config to figure out what parameters were fit or not (instead of removing NA values)

#these_states=c('MA','NY','AZ','CA','IL','TX')
these_states = params$states

for (this_state in these_states){
  
  this_state_name=str_replace_all(geodata_all$name[geodata_all$USPS==this_state]," ","")
  
  snpi_interm_mat <- snpi_interm %>% 
    filter(USPS==this_state) %>% 
    dplyr::filter(lik_type=='chimeric')%>%
    dplyr::select(c("npi_name","reduction","iter_num")) %>% 
    drop_na() %>% 
    tidyr::spread(npi_name,reduction) %>% 
    dplyr::select(-starts_with("Dose")) %>% # remove variables that were not fit (otherwise get NAs in correlation matrix due to zero STD)
    #select_if(~ !any(is.na(.)))   # remove any other rows or columns with NA values 
    dplyr::select(where(~!sd(.) == 0)) # remove any other rows or columns with NA values 
  
  snpi_interm_mat$iter_num <- NULL
  names(snpi_interm_mat) <- str_remove(names(snpi_interm_mat),fixed(paste0(this_state_name,'_'),ignore_case=TRUE)) # remove states names from intervention names
  
  snpi_interm_cor = cor(snpi_interm_mat)
  
  corrplot(cor(snpi_interm_mat), method = "ellipse",order = "hclust", addrect = 3, title=this_state_name)
  
}


```
### Do an extra analysis calculating the average correlation over all states and plotting

```{r}
#these_states=c('MA','NY','AZ','CA','IL','TX')

all_snpi_interm_cor<- data.frame(Var1=character(),Var2=character(),value=double(),state=character())

these_states <- unique(snpi_interm$USPS)

for (this_state in these_states){
  
  this_state_name=str_replace_all(geodata_all$name[geodata_all$USPS==this_state]," ","")
  if (this_state == "VI"){
    this_state_name="VIRGINISLANDS"
  }
  
  snpi_interm_mat <- snpi_interm %>% 
    filter(USPS==this_state) %>% 
    dplyr::filter(lik_type=='chimeric')%>%
    dplyr::select(c("npi_name","reduction","iter_num")) %>% 
    drop_na() %>% 
    tidyr::spread(npi_name,reduction) %>% 
    dplyr::select(-starts_with("Dose")) %>% # remove variables that were not fit (otherwise get NAs in correlation matrix due to zero STD)
    #select_if(~ !any(is.na(.)))   # remove any other rows or columns with NA values 
    dplyr::select(where(~!sd(.) == 0)) # remove any other rows or columns with NA values 
  
  snpi_interm_mat$iter_num <- NULL
  names(snpi_interm_mat) <- str_remove(names(snpi_interm_mat),fixed(paste0(this_state_name,'_'),ignore_case=TRUE)) # remove states names from intervention names
  
  snpi_interm_cor <- cor(snpi_interm_mat)
  
  all_snpi_interm_cor <-rbind(all_snpi_interm_cor,mutate(melt(snpi_interm_cor),state=this_state_name))
  
  #corrplot(cor(snpi_interm_mat), method = "ellipse",order = "hclust", addrect = 3, title=this_state_name)
  
}
```

```{r}
mean_snpi_interm_cor <- all_snpi_interm_cor %>% group_by(Var1,Var2) %>% summarize(mean_corr=mean(value))
mean_snpi_interm_cor$Var1 <-str_replace_all(mean_snpi_interm_cor$Var1,
                                            c("seas_jan"="seas_01jan",
                                              "seas_feb"="seas_02feb",
                                              "seas_mar"="seas_03mar",
                                              "seas_apr"="seas_04apr",
                                              "seas_may"="seas_05may",
                                              "seas_jun"="seas_06jun",
                                              "seas_jul"="seas_07jul",
                                              "seas_aug"="seas_08aug",
                                              "seas_sep"="seas_09sep",
                                              "seas_oct"="seas_10oct",
                                              "seas_nov"="seas_11nov",
                                              "seas_dec"="seas_12dec"
                                              ))
mean_snpi_interm_cor$Var2 <-str_replace_all(mean_snpi_interm_cor$Var2,
                                            c("seas_jan"="seas_01jan",
                                              "seas_feb"="seas_02feb",
                                              "seas_mar"="seas_03mar",
                                              "seas_apr"="seas_04apr",
                                              "seas_may"="seas_05may",
                                              "seas_jun"="seas_06jun",
                                              "seas_jul"="seas_07jul",
                                              "seas_aug"="seas_08aug",
                                              "seas_sep"="seas_09sep",
                                              "seas_oct"="seas_10oct",
                                              "seas_nov"="seas_11nov",
                                              "seas_dec"="seas_12dec"
                                              ))

mean_snpi_interm_cor_mat <- mean_snpi_interm_cor %>% 
    tidyr::spread(Var2,mean_corr) %>%
    mutate_all(~replace(.,is.na(.),0))
mean_snpi_interm_cor_mat$Var1<- NULL


corrplot(cor(mean_snpi_interm_cor_mat), method = "ellipse",order = "hclust", addrect = 4, title="Mean over all states")
corrplot(cor(mean_snpi_interm_cor_mat), method = "ellipse",order = "alphabet", title="Mean over all states")
```


## Look at variance of each parameter from the posterior and compare to the proposal step size

This is a way of measuring whether adaptive MCMC could help. (Ignore covariance for now). If observed std >> perturb_sd, suggests that proposal too small. If observed_sd << perturb_sd, suggests proposal too big

```{r}

# calculate variance for runs for a certain range of iterations (after ~100 runs acceptance ->0)
iter_start <-0
iter_finish <-100

snpi_interm_var_mat <- snpi_interm %>% drop_na() %>% filter(iter_num > iter_start & iter_num < iter_finish) %>% dplyr::filter(lik_type=='chimeric')%>% group_by(geoid,scenario,pdeath,lik_type,npi_name) %>% dplyr::summarize(npi_sd_observed=sd(reduction)) %>% ungroup()

# Get the perturbation values used in the simulation from the config file

snpi_fit_inds <- config$interventions$settings[unlist(lapply(config$interventions$settings, exists, x="perturbation"))]
snpi_fit_names <- names(snpi_fit_inds)# %>%
#str_remove(npi_trimmer) %>%
#unique() # NOTE: this assumes all interventions have inference, if the projections for some geoids do NOT have inference, then you will need to modify the input to the Rt/effectiveness plots

#get original perturbation
snpi_fit_perturb_sd <- lapply(snpi_fit_names,function(x){config$interventions$settings[[x]]$perturbation$sd})

# make a table of NPI name and perturbation
snpi_fit_df <- data.frame(unlist(snpi_fit_names),unlist(snpi_fit_perturb_sd))
names(snpi_fit_df) <- c("npi_name","npi_sd_input")

snpi_interm_var_mat <- snpi_interm_var_mat %>% left_join(snpi_fit_df)  %>% drop_na()

snpi_interm_var_mat$npi_sd_fold_change <-snpi_interm_var_mat$npi_sd_observed/snpi_interm_var_mat$npi_sd_input

snpi_interm_var_mat
# compare

```



